int fill_sorted_active_table(char *sorted_active_table,char **tip_first_key, char **tip_last_key){
	//printf("--------fill_sorted_active_table begin\n");

	struct ATABLE *active_table_old=active_table;
	active_table=NULL;
	active_table = (struct ATABLE *)malloc(sizeof(struct ATABLE));//this should be able to serve new writes immediatly
	memset(active_table, 0 , sizeof(struct ATABLE));
	
	struct KNODE *curr_node=active_table_old->key_head;//need to free, a linked list
	int i;

	for(;curr_node->next!=NULL;){ //sort the link list
	//every cycle make the smallest remain knode  to the current position
	//compare one by one with the following knodes, if this is bigger, then exchange their KV data
	//
		struct KNODE *stamp=curr_node;
		//printf("xxxxxxxxxxxxxxxx\n");
		for(;stamp->next!=NULL;){
			struct KNODE *no_name= stamp->next;
			
			if(strcmp(curr_node->key, no_name->key) ==0){//delete the repeated key nodes			
				stamp->next=no_name->next;
				free(no_name->key);
				free(no_name->value);	
				free(no_name);				
				continue;
			}
			//printf("zzzzzzzzzzzzz\n");
			if(strcmp(curr_node->key, no_name->key) >0 ){//exchange the KV
				
				char *temp_key= no_name->key;
				char *temp_value= no_name->value;
				no_name->key= curr_node->key;
				no_name->value=curr_node->value;				
				curr_node->key=temp_key;
				curr_node->value=temp_value;
				
			}
			stamp=stamp->next;
		}
		
		//printf("end for\n");
		//printf("end for 1. curr_node=%p, curr_node->next=%p\n",curr_node,curr_node->next);
		if(curr_node->next==NULL) break; 
		curr_node=curr_node->next;//sort the next node
		//printf("end for 2. curr_node=%p\n",curr_node);
	}

	int copied_size=0;//indicates the total bytes of data have been copied to sorted_active_table
	for(curr_node=active_table_old->key_head;curr_node->next!=NULL;curr_node=curr_node->next){
		memcpy(sorted_active_table+copied_size, curr_node->key, strlen(curr_node->key)+1 );
		copied_size+=strlen(curr_node->key)+1;
		memcpy(sorted_active_table+copied_size, curr_node->value, strlen(curr_node->value)+1 );
		copied_size+=strlen(curr_node->value)+1;	
	}
	
	//leave the last for getting the last key without if clause --begin
	int last_key_offset=copied_size;
	memcpy(sorted_active_table+copied_size, curr_node->key, strlen(curr_node->key)+1 );
	copied_size+=strlen(curr_node->key)+1;
	memcpy(sorted_active_table+copied_size, curr_node->value, strlen(curr_node->value)+1 );
	copied_size+=strlen(curr_node->value)+1;
	char *active_first_key=sorted_active_table;//active_table_old->key_head->key;
	char *active_last_key=sorted_active_table+last_key_offset;//curr_node->key;
	//printf("first_key:%s last_key:%s\n",active_first_key,active_last_key);
	//leave the last for getting the last key without if clause --end
	//construct a sorted table --end
	//free struct ATABLE *active_table_old
		*tip_first_key=active_first_key;
		*tip_last_key=active_last_key;
	for(curr_node=active_table_old->key_head;curr_node!=NULL;){
		free(curr_node->key);
		free(curr_node->value);
		struct KNODE *temp=curr_node;
		curr_node=curr_node->next;
		free(temp);
			//free big table
	}
	free(active_table_old);
	
	//printf("--------fill_sorted_active_table end\n");
	
}

